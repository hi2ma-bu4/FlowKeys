{
  "version": 3,
  "sources": ["../src/FlowKeys.ts"],
  "sourcesContent": ["type Key = KeyboardEvent[\"key\"];\ntype CommandCallback = () => void;\ntype KeyCombo = Set<Key>;\n\ninterface TrieNode {\n\tchildren: Map<string, TrieNode>;\n\tcallback?: CommandCallback;\n}\n\nexport class FlowKeys {\n\tprivate root: TrieNode = { children: new Map() };\n\tprivate buffer: KeyCombo[] = [];\n\tprivate maxSequenceLength = 0;\n\tprivate pressedKeys: Set<Key> = new Set();\n\tprivate aliasMap: Map<Key, Key[]> = new Map();\n\tprivate target: HTMLElement | Document | Window;\n\tprivate keyPushTimeout = 30;\n\tprivate keyPushTimer: number | null = null;\n\n\t// 標準化マップ（OS/ブラウザ差異の吸収）\n\tprivate static STANDARD_KEY_MAP: Record<Key, Key> = {\n\t\tEsc: \"Escape\",\n\t\tDel: \"Delete\",\n\t\tReturn: \"Enter\",\n\t\tLeft: \"ArrowLeft\",\n\t\tRight: \"ArrowRight\",\n\t\tUp: \"ArrowUp\",\n\t\tDown: \"ArrowDown\",\n\t\t\" \": \"Space\",\n\t\tCtrl: \"Control\",\n\t\tCmd: \"Meta\",\n\t\tWindows: \"Meta\",\n\t};\n\n\tconstructor(target?: HTMLElement | Document | Window) {\n\t\tthis.target = (target ?? window) as Window;\n\t\tthis.handleKeyDown = this.handleKeyDown.bind(this);\n\t\tthis.handleKeyUp = this.handleKeyUp.bind(this);\n\t\tthis.target.addEventListener(\"keydown\", this.handleKeyDown, true);\n\t\tthis.target.addEventListener(\"keyup\", this.handleKeyUp, true);\n\t}\n\n\t// 代替キー登録\n\tpublic addAlias(key: Key, aliases: Key[]) {\n\t\tthis.aliasMap.set(\n\t\t\tkey.toLowerCase(),\n\t\t\taliases.map((k) => k.toLowerCase())\n\t\t);\n\t}\n\n\t// シーケンス登録\n\tpublic register(sequence: (Key | Key[])[], callback: CommandCallback) {\n\t\tif (!sequence.length) return;\n\t\tthis.maxSequenceLength = Math.max(this.maxSequenceLength, sequence.length);\n\n\t\tlet node = this.root;\n\t\tfor (const item of sequence) {\n\t\t\tconst combo = new Set(Array.isArray(item) ? item : [item]);\n\t\t\tconst key = FlowKeys.setToKey(this.normalizeCombo(combo));\n\t\t\tif (!node.children.has(key)) node.children.set(key, { children: new Map() });\n\t\t\tnode = node.children.get(key)!;\n\t\t}\n\t\tnode.callback = callback;\n\t}\n\n\tprivate normalizeCombo(combo: KeyCombo): KeyCombo {\n\t\tconst normalized = new Set<Key>();\n\t\tfor (let k of combo) {\n\t\t\t// 標準化キーに変換\n\t\t\tk = (FlowKeys.STANDARD_KEY_MAP[k] ?? k).toLowerCase();\n\n\t\t\tlet mapped = false;\n\t\t\tfor (const [key, aliases] of this.aliasMap) {\n\t\t\t\tif (aliases.includes(k)) {\n\t\t\t\t\tnormalized.add(key);\n\t\t\t\t\tmapped = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!mapped) normalized.add(k);\n\t\t}\n\t\treturn normalized;\n\t}\n\n\tprivate static setToKey(combo: KeyCombo) {\n\t\treturn Array.from(combo).sort().join(\"+\");\n\t}\n\n\tprivate handleKeyDown(event: KeyboardEvent) {\n\t\tconst key = (FlowKeys.STANDARD_KEY_MAP[event.key] ?? event.key).toLowerCase();\n\t\tconst now = performance.now();\n\n\t\tthis.pressedKeys.add(key);\n\n\t\tif (this.keyPushTimer !== null) clearTimeout(this.keyPushTimer);\n\t\tthis.keyPushTimer = window.setTimeout(() => {\n\t\t\tthis.updateBuffer();\n\t\t\tthis.keyPushTimer = null;\n\t\t}, this.keyPushTimeout);\n\t}\n\n\tprivate handleKeyUp(event: KeyboardEvent) {\n\t\tconst key = (FlowKeys.STANDARD_KEY_MAP[event.key] ?? event.key).toLowerCase();\n\t\tthis.pressedKeys.delete(key);\n\t}\n\n\tprivate updateBuffer() {\n\t\tconst comboKey = this.normalizeCombo(this.pressedKeys);\n\t\tthis.buffer.push(comboKey);\n\t\tif (this.buffer.length > this.maxSequenceLength) this.buffer.shift();\n\t\tthis.checkBuffer();\n\t}\n\n\tprivate checkBuffer() {\n\t\tif (!this.buffer.length) return;\n\t\tconsole.log(this.buffer);\n\t\tlet node = this.root;\n\t\t// 最新入力から先頭まで順にたどる\n\t\tfor (let i = this.buffer.length - this.maxSequenceLength; i < this.buffer.length; i++) {\n\t\t\tif (i < 0) continue;\n\t\t\tnode = this.root;\n\t\t\tlet match = true;\n\t\t\tfor (let j = i; j < this.buffer.length; j++) {\n\t\t\t\tconst keyStr = FlowKeys.setToKey(this.buffer[j]);\n\t\t\t\tif (!node.children.has(keyStr)) {\n\t\t\t\t\tmatch = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnode = node.children.get(keyStr)!;\n\t\t\t}\n\t\t\tif (match && node.callback) {\n\t\t\t\tnode.callback();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic destroy() {\n\t\t(this.target as Window).removeEventListener(\"keydown\", this.handleKeyDown, true);\n\t\t(this.target as Window).removeEventListener(\"keyup\", this.handleKeyUp, true);\n\t\tif (this.keyPushTimer !== null) clearTimeout(this.keyPushTimer);\n\t\tthis.buffer = [];\n\t\tthis.root = { children: new Map() };\n\t\tthis.pressedKeys.clear();\n\t\tthis.aliasMap.clear();\n\t\tthis.maxSequenceLength = 0;\n\t}\n}\n\nif (typeof window !== \"undefined\") {\n\t(window as any).FlowKeys = FlowKeys;\n}\n"],
  "mappings": "AASO,IAAMA,EAAN,MAAMC,CAAS,CACb,KAAiB,CAAE,SAAU,IAAI,GAAM,EACvC,OAAqB,CAAC,EACtB,kBAAoB,EACpB,YAAwB,IAAI,IAC5B,SAA4B,IAAI,IAChC,OACA,eAAiB,GACjB,aAA8B,KAGtC,OAAe,iBAAqC,CACnD,IAAK,SACL,IAAK,SACL,OAAQ,QACR,KAAM,YACN,MAAO,aACP,GAAI,UACJ,KAAM,YACN,IAAK,QACL,KAAM,UACN,IAAK,OACL,QAAS,MACV,EAEA,YAAYC,EAA0C,CACrD,KAAK,OAAUA,GAAU,OACzB,KAAK,cAAgB,KAAK,cAAc,KAAK,IAAI,EACjD,KAAK,YAAc,KAAK,YAAY,KAAK,IAAI,EAC7C,KAAK,OAAO,iBAAiB,UAAW,KAAK,cAAe,EAAI,EAChE,KAAK,OAAO,iBAAiB,QAAS,KAAK,YAAa,EAAI,CAC7D,CAGO,SAASC,EAAUC,EAAgB,CACzC,KAAK,SAAS,IACbD,EAAI,YAAY,EAChBC,EAAQ,IAAKC,GAAMA,EAAE,YAAY,CAAC,CACnC,CACD,CAGO,SAASC,EAA2BC,EAA2B,CACrE,GAAI,CAACD,EAAS,OAAQ,OACtB,KAAK,kBAAoB,KAAK,IAAI,KAAK,kBAAmBA,EAAS,MAAM,EAEzE,IAAIE,EAAO,KAAK,KAChB,QAAWC,KAAQH,EAAU,CAC5B,IAAMI,EAAQ,IAAI,IAAI,MAAM,QAAQD,CAAI,EAAIA,EAAO,CAACA,CAAI,CAAC,EACnDN,EAAMF,EAAS,SAAS,KAAK,eAAeS,CAAK,CAAC,EACnDF,EAAK,SAAS,IAAIL,CAAG,GAAGK,EAAK,SAAS,IAAIL,EAAK,CAAE,SAAU,IAAI,GAAM,CAAC,EAC3EK,EAAOA,EAAK,SAAS,IAAIL,CAAG,CAC7B,CACAK,EAAK,SAAWD,CACjB,CAEQ,eAAeG,EAA2B,CACjD,IAAMC,EAAa,IAAI,IACvB,QAASN,KAAKK,EAAO,CAEpBL,GAAKJ,EAAS,iBAAiBI,CAAC,GAAKA,GAAG,YAAY,EAEpD,IAAIO,EAAS,GACb,OAAW,CAACT,EAAKC,CAAO,IAAK,KAAK,SACjC,GAAIA,EAAQ,SAASC,CAAC,EAAG,CACxBM,EAAW,IAAIR,CAAG,EAClBS,EAAS,GACT,KACD,CAEIA,GAAQD,EAAW,IAAIN,CAAC,CAC9B,CACA,OAAOM,CACR,CAEA,OAAe,SAASD,EAAiB,CACxC,OAAO,MAAM,KAAKA,CAAK,EAAE,KAAK,EAAE,KAAK,GAAG,CACzC,CAEQ,cAAcG,EAAsB,CAC3C,IAAMV,GAAOF,EAAS,iBAAiBY,EAAM,GAAG,GAAKA,EAAM,KAAK,YAAY,EACtEC,EAAM,YAAY,IAAI,EAE5B,KAAK,YAAY,IAAIX,CAAG,EAEpB,KAAK,eAAiB,MAAM,aAAa,KAAK,YAAY,EAC9D,KAAK,aAAe,OAAO,WAAW,IAAM,CAC3C,KAAK,aAAa,EAClB,KAAK,aAAe,IACrB,EAAG,KAAK,cAAc,CACvB,CAEQ,YAAYU,EAAsB,CACzC,IAAMV,GAAOF,EAAS,iBAAiBY,EAAM,GAAG,GAAKA,EAAM,KAAK,YAAY,EAC5E,KAAK,YAAY,OAAOV,CAAG,CAC5B,CAEQ,cAAe,CACtB,IAAMY,EAAW,KAAK,eAAe,KAAK,WAAW,EACrD,KAAK,OAAO,KAAKA,CAAQ,EACrB,KAAK,OAAO,OAAS,KAAK,mBAAmB,KAAK,OAAO,MAAM,EACnE,KAAK,YAAY,CAClB,CAEQ,aAAc,CACrB,GAAI,CAAC,KAAK,OAAO,OAAQ,OACzB,QAAQ,IAAI,KAAK,MAAM,EACvB,IAAIP,EAAO,KAAK,KAEhB,QAAS,EAAI,KAAK,OAAO,OAAS,KAAK,kBAAmB,EAAI,KAAK,OAAO,OAAQ,IAAK,CACtF,GAAI,EAAI,EAAG,SACXA,EAAO,KAAK,KACZ,IAAIQ,EAAQ,GACZ,QAASC,EAAI,EAAGA,EAAI,KAAK,OAAO,OAAQA,IAAK,CAC5C,IAAMC,EAASjB,EAAS,SAAS,KAAK,OAAOgB,CAAC,CAAC,EAC/C,GAAI,CAACT,EAAK,SAAS,IAAIU,CAAM,EAAG,CAC/BF,EAAQ,GACR,KACD,CACAR,EAAOA,EAAK,SAAS,IAAIU,CAAM,CAChC,CACIF,GAASR,EAAK,UACjBA,EAAK,SAAS,CAEhB,CACD,CAEO,SAAU,CACf,KAAK,OAAkB,oBAAoB,UAAW,KAAK,cAAe,EAAI,EAC9E,KAAK,OAAkB,oBAAoB,QAAS,KAAK,YAAa,EAAI,EACvE,KAAK,eAAiB,MAAM,aAAa,KAAK,YAAY,EAC9D,KAAK,OAAS,CAAC,EACf,KAAK,KAAO,CAAE,SAAU,IAAI,GAAM,EAClC,KAAK,YAAY,MAAM,EACvB,KAAK,SAAS,MAAM,EACpB,KAAK,kBAAoB,CAC1B,CACD,EAEI,OAAO,OAAW,MACpB,OAAe,SAAWR",
  "names": ["FlowKeys", "_FlowKeys", "target", "key", "aliases", "k", "sequence", "callback", "node", "item", "combo", "normalized", "mapped", "event", "now", "comboKey", "match", "j", "keyStr"]
}
